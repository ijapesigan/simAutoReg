# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Simulate Data from a Vector Autoregressive (VAR) Model with Exogenous
NULL

#' Simulate Data from an Autoregressive Model with Constant Term
#'
#' This function generates synthetic time series data
#' from an autoregressive (AR) model.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param time Integer.
#'   Number of time points to simulate.
#' @param burn_in Integer.
#'   Number of burn-in periods before recording data.
#' @param constant Numeric.
#'   The constant term of the AR model.
#' @param coef Numeric vector.
#'   Autoregressive coefficients.
#' @param sd Numeric.
#'   The standard deviation of the random process noise.
#'
#' @return Numeric vector (column matrix) containing the simulated
#'   time series data.
#'
#' @examples
#' set.seed(42)
#' SimAR(time = 10, burn_in = 5, constant = 2, coef = c(0.5, -0.3), sd = 0.1)
#'
#' @details
#' The [SimAR()] function generates synthetic time series data
#' from an autoregressive (AR) model.
#' The generated data follows the AR(p) model,
#' where `p` is the number of coefficients specified in `coef`.
#' The generated time series data includes a constant term
#' and autoregressive terms based on the provided coefficients.
#' Random noise, sampled from a normal distribution with mean 0
#' and standard deviation `sd`, is added to the time series.
#' A burn-in period is specified to exclude initial data points
#' from the output.
#'
#' The steps in generating the autoregressive time series with burn-in
#' are as follows:
#'
#' - Set the order of the AR model to `p` based on the length of `coef`.
#' - Create a vector data of size `time + burn_in`
#'   to store the generated AR time series data.
#' - Create a vector data of size `time + burn_in` of random process noise
#'   from a normal distribution with mean 0
#'   and standard deviation `sd`.
#' - Generate the autoregressive time series with burn-in using the formula:
#'   \deqn{Y_t = constant + \sum_{i=1}^{p} (coef[i] * Y_{t-i}) + noise_t}
#'   where \eqn{Y_t} is the time series data at time \eqn{t}, \eqn{constant}
#'   is the constant term,
#'   \eqn{coef[i]} are the autoregressive coefficients,
#'   \eqn{Y_{t-i}} are the lagged data points up to order `p`,
#'   and \eqn{noise_t} is the random noise at time \eqn{t}.
#' - Remove the burn-in period from the generated time series data.
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg sim
#' @export
SimAR <- function(time, burn_in, constant, coef, sd) {
    .Call(`_simAutoReg_SimAR`, time, burn_in, constant, coef, sd)
}

#' Simulate Multivariate Normal Random Numbers with Optional Fixed Values
#'
#' This function generates multivariate normal random numbers
#' with optinal fixed values where the variance is zero.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param n Integer.
#'   Number of samples to generate.
#' @param location Numeric vector.
#'   Mean vector of length `k`, where `k` is the number of variables.
#' @param scale Numeric matrix.
#'   Covariance matrix of dimensions `k` by `k`.
#'   Values for variables with variance of `0` will be fixed
#'   to the corresponding value in `location`.
#'
#' @return Matrix containing the simulated multivariate normal random numbers,
#'   with dimensions `n` by `k`, where `n` is the number of samples
#'   and `k` is the number of variables.
#'
#' @examples
#' set.seed(42)
#' n <- 1000L
#' location <- c(0.5, -0.2, 0.1)
#' scale <- matrix(
#'   data = c(0, 0.3, 0.3, 0.3, 1.0, 0.2, 0.3, 0.2, 1.0),
#'   nrow = 3,
#'   byrow = TRUE
#' )
#' y <- SimMVNFixed(n = n, location = location, scale = scale)
#' colMeans(y)
#' var(y)
#'
#' @details
#' The [SimMVNFixed()] function first identifies the indices
#' of non-constant variables (i.e., variables with variance not equal to 0)
#' in the covariance matrix.
#' It then extracts the non-constant elements from the mean vector
#' and the covariance matrix.
#' A Cholesky decomposition is performed on the covariance matrix
#' of non-constant variables.
#' Random samples are generated for the non-constant variables
#' using the Cholesky factor.
#' The generated data matrix is constructed
#' by setting the non-constant variables
#' and constant variables to their corresponding values.
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg sim
#' @export
SimMVNFixed <- function(n, location, scale) {
    .Call(`_simAutoReg_SimMVNFixed`, n, location, scale)
}

#' Simulate Multivariate Normal Random Numbers
#'
#' This function generates multivariate normal random numbers.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param n Integer.
#'   Number of samples to generate.
#' @param location Numeric vector.
#'   Mean vector of length `k`, where `k` is the number of variables.
#' @param chol_scale Numeric matrix.
#'   Cholesky decomposition of the covariance matrix of dimensions `k` by `k`.
#'
#' @return Matrix containing the simulated multivariate normal random numbers,
#'   with dimensions `n` by `k`, where `n` is the number of samples
#'   and `k` is the number of variables.
#'
#' @examples
#' set.seed(42)
#' n <- 1000L
#' location <- c(0.5, -0.2, 0.1)
#' scale <- matrix(
#'   data = c(1.0, 0.3, 0.3, 0.3, 1.0, 0.2, 0.3, 0.2, 1.0),
#'   nrow = 3,
#'   byrow = TRUE
#' )
#' chol_scale <- chol(scale)
#' y <- SimMVN(n = n, location = location, chol_scale = chol_scale)
#' colMeans(y)
#' var(y)
#'
#' @details
#' The [SimMVN()] function generates
#' multivariate normal random numbers
#' using the Cholesky decomposition method.
#' Given the number of samples `n`, the mean vector `location` of length `k`
#' (where `k` is the number of variables),
#' and the Cholesky decomposition `chol_scale` of the covariance matrix
#' of dimensions `k` by `k`,
#' the function produces a matrix of multivariate normal random numbers.
#'
#' The steps involved in generating multivariate normal random numbers
#' are as follows:
#'
#' - Determine the number of variables `k` from the length of the mean vector.
#' - Generate random data from a standard multivariate normal distribution,
#'   resulting in an `n` by `k` matrix of random numbers.
#' - Transform the standard normal random data
#'   into multivariate normal random data
#'   using the Cholesky decomposition `chol_scale`.
#' - Add the mean vector `location` to the transformed data
#'   to obtain the final simulated multivariate normal random numbers.
#' - The function returns a matrix of simulated
#'   multivariate normal random numbers
#'   with dimensions `n` by `k`,
#'   where `n` is the number of samples and `k` is the number of variables.
#'   This matrix can be used for various statistical analyses and simulations.
#'
#' @seealso
#' The [chol()] function in R to obtain the Cholesky decomposition
#' of a covariance matrix.
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg sim
#' @export
SimMVN <- function(n, location, chol_scale) {
    .Call(`_simAutoReg_SimMVN`, n, location, chol_scale)
}

#'
#' This function generates synthetic time series data
#' from a Vector Autoregressive (VAR) model with exogenous variables.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param time Integer.
#'   Number of time points to simulate.
#' @param burn_in Integer.
#'   Number of burn-in observations to exclude before returning the results.
#' @param constant Numeric vector.
#'   The constant term vector of length `k`,
#'   where `k` is the number of variables.
#' @param coef Numeric matrix.
#'   Coefficient matrix with dimensions `k` by `(k * p)`.
#'   Each `k` by `k` block corresponds to the coefficient matrix
#'   for a particular lag.
#' @param chol_cov Numeric matrix.
#'   The Cholesky decomposition of the covariance matrix
#'   of the multivariate normal noise.
#'   It should have dimensions `k` by `k`.
#' @param exo_mat Numeric matrix.
#'   Matrix of exogenous covariates with dimensions `time + burn_in` by `x`.
#'   Each column corresponds to a different exogenous variable.
#' @param exo_coef Numeric vector.
#'   Coefficient matrix with dimensions `k` by `x`
#'   associated with the exogenous covariates.
#'
#' @return Numeric matrix containing the simulated time series data
#'   with dimensions `k` by `time`,
#'   where `k` is the number of variables and
#'   `time` is the number of observations.
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg sim
#' @export
SimVARExo <- function(time, burn_in, constant, coef, chol_cov, exo_mat, exo_coef) {
    .Call(`_simAutoReg_SimVARExo`, time, burn_in, constant, coef, chol_cov, exo_mat, exo_coef)
}

#' Simulate Data from a Vector Autoregressive Zero-Inflated Poisson (VARZIP)
#' Model with Exogenous Variables
#'
#' This function generates synthetic time series data
#' from a Vector Autoregressive Zero-Inflated Poisson (VARZIP) model
#' with exogenous variables.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param time Integer.
#'   Number of time points to simulate.
#' @param burn_in Integer.
#'   Number of burn-in observations to exclude before returning the results.
#' @param constant Numeric vector.
#'   The constant term vector of length `k`,
#'   where `k` is the number of variables.
#' @param coef Numeric matrix.
#'   Coefficient matrix with dimensions `k` by `(k * p)`.
#'   Each `k` by `k` block corresponds to the coefficient matrix
#'   for a particular lag.
#' @param chol_cov Numeric matrix.
#'   The Cholesky decomposition of the covariance matrix
#'   of the multivariate normal noise.
#'   It should have dimensions `k` by `k`.
#' @param exo_mat Numeric matrix.
#'   Matrix of exogenous covariates with dimensions `time + burn_in` by `x`.
#'   Each column corresponds to a different exogenous variable.
#' @param exo_coef Numeric vector.
#'   Coefficient matrix with dimensions `k` by `x`
#'   associated with the exogenous covariates.
#'
#' @return Numeric matrix containing the simulated time series data
#'   with dimensions `k` by `time`,
#'   where `k` is the number of variables
#'   and `time` is the number of observations.
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg sim
#' @export
SimVARZIPExo <- function(time, burn_in, constant, coef, chol_cov, exo_mat, exo_coef) {
    .Call(`_simAutoReg_SimVARZIPExo`, time, burn_in, constant, coef, chol_cov, exo_mat, exo_coef)
}

#' Simulate Data from a Vector Autoregressive Zero-Inflated Poisson (VARZIP)
#' Model
#'
#' This function generates synthetic time series data
#' from a Vector Autoregressive Zero-Inflated Poisson (VARZIP) model.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param time Integer.
#'   Number of time points to simulate.
#' @param burn_in Integer.
#'   Number of burn-in observations to exclude before returning the results.
#' @param constant Numeric vector.
#'   The constant term vector of length `k`,
#'   where `k` is the number of variables.
#' @param coef Numeric matrix.
#'   Coefficient matrix with dimensions `k` by `(k * p)`.
#'   Each `k` by `k` block corresponds to the coefficient matrix
#'   for a particular lag.
#' @param chol_cov Numeric matrix.
#'   The Cholesky decomposition of the covariance matrix
#'   of the multivariate normal noise.
#'   It should have dimensions `k` by `k`.
#'
#' @return Numeric matrix containing the simulated time series data
#'   with dimensions `k` by `time`,
#'   where `k` is the number of variables
#'   and `time` is the number of observations.
#'
#' @examples
#' set.seed(42)
#' time <- 50L
#' burn_in <- 10L
#' k <- 3
#' p <- 2
#' constant <- c(1, 1, 1)
#' coef <- matrix(
#'   data = c(
#'     0.4, 0.0, 0.0, 0.1, 0.0, 0.0,
#'     0.0, 0.5, 0.0, 0.0, 0.2, 0.0,
#'     0.0, 0.0, 0.6, 0.0, 0.0, 0.3
#'   ),
#'   nrow = k,
#'   byrow = TRUE
#' )
#' chol_cov <- chol(diag(3))
#' y <- SimVARZIP(
#'   time = time,
#'   burn_in = burn_in,
#'   constant = constant,
#'   coef = coef,
#'   chol_cov = chol_cov
#' )
#' head(y)
#'
#' @details
#' The [SimVARZIP()] function generates synthetic time series data
#' from a Vector Autoregressive (VAR)
#' with Zero-Inflated Poisson (ZIP) model for the first observed variable.
#' See [SimVAR()] for more details on generating data for VAR(p).
#' The `SimVARZIP` function goes further by using the generated values
#' for the first variable to generate data from the ZIP model.
#' The exponential of the values from the first variable
#' from the original VAR(p) model
#' are used as the `intensity` parameter in the Poisson distribution
#' in the ZIP model.
#' Data from the ZIP model are used to replace the original values
#' for the first variable.
#' Values for the rest of the variables are unchanged.
#' The generated data includes a burn-in period,
#' which is excluded before returning the results.
#'
#' The steps involved in generating the time series data are as follows:
#'
#' - Extract the number of variables `k`
#'   and the number of lags `p` from the input.
#' - Create a matrix `data` of size `k` x (`time + burn_in`)
#'   to store the generated data.
#' - Set the initial values of the matrix `data`
#'   using the constant term `constant`.
#' - For each time point starting from the `p`-th time point
#'   to `time + burn_in - 1`:
#'   * Generate a vector of random process noise
#'     from a multivariate normal distribution
#'     with mean 0 and covariance matrix `chol_cov`.
#'   * Generate the VAR time series values for each variable `j`
#'     at time `t` by applying the autoregressive terms
#'     for each lag `lag` and each variable `l`.
#'     - Add the generated noise to the VAR time series values.
#'     - For the first variable,
#'       apply the Zero-Inflated Poisson (ZIP) model:
#'       * Compute the intensity `intensity`
#'         as the exponential of the first variable's value at time `t`.
#'       * Sample a random value `u`
#'         from a uniform distribution on \[0, 1\].
#'       * If `u` is less than `intensity / (1 + intensity)`,
#'         set the first variable's value to zero (inflation).
#'       * Otherwise, sample the first variable's value
#'         from a Poisson distribution
#'         with mean `intensity` (count process).
#' - Transpose the data matrix `data` and return only
#'   the required time period after burn-in as a numeric matrix.
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg sim
#' @export
SimVARZIP <- function(time, burn_in, constant, coef, chol_cov) {
    .Call(`_simAutoReg_SimVARZIP`, time, burn_in, constant, coef, chol_cov)
}

#' Simulate Data from a Vector Autoregressive (VAR) Model
#'
#' This function generates synthetic time series data
#' from a Vector Autoregressive (VAR) model.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param time Integer.
#'   Number of time points to simulate.
#' @param burn_in Integer.
#'   Number of burn-in observations to exclude before returning the results.
#' @param constant Numeric vector.
#'   The constant term vector of length `k`,
#'   where `k` is the number of variables.
#' @param coef Numeric matrix.
#'   Coefficient matrix with dimensions `k` by `(k * p)`.
#'   Each `k` by `k` block corresponds to the coefficient matrix
#'   for a particular lag.
#' @param chol_cov Numeric matrix.
#'   The Cholesky decomposition of the covariance matrix
#'   of the multivariate normal noise.
#'   It should have dimensions `k` by `k`.
#'
#' @return Numeric matrix containing the simulated time series data
#'   with dimensions `k` by `time`,
#'   where `k` is the number of variables and
#'   `time` is the number of observations.
#'
#' @examples
#' set.seed(42)
#' time <- 50L
#' burn_in <- 10L
#' k <- 3
#' p <- 2
#' constant <- c(1, 1, 1)
#' coef <- matrix(
#'   data = c(
#'     0.4, 0.0, 0.0, 0.1, 0.0, 0.0,
#'     0.0, 0.5, 0.0, 0.0, 0.2, 0.0,
#'     0.0, 0.0, 0.6, 0.0, 0.0, 0.3
#'   ),
#'   nrow = k,
#'   byrow = TRUE
#' )
#' chol_cov <- chol(diag(3))
#' y <- SimVAR(
#'   time = time,
#'   burn_in = burn_in,
#'   constant = constant,
#'   coef = coef,
#'   chol_cov = chol_cov
#' )
#' head(y)
#'
#' @details
#' The [SimVAR()] function generates synthetic time series data
#' from a Vector Autoregressive (VAR) model.
#' The VAR model is defined by the constant term `constant`,
#' the coefficient matrix `coef`,
#' and the Cholesky decomposition of the covariance matrix
#' of the multivariate normal process noise `chol_cov`.
#' The generated time series data follows a VAR(p) process,
#' where `p` is the number of lags specified by the size of `coef`.
#' The generated data includes a burn-in period,
#' which is excluded before returning the results.
#'
#' The steps involved in generating the VAR time series data are as follows:
#'
#' - Extract the number of variables `k` and the number of lags `p`
#'   from the input.
#' - Create a matrix `data` of size `k` by (`time + burn_in`)
#'   to store the generated VAR time series data.
#' - Set the initial values of the matrix `data`
#'   using the constant term `constant`.
#' - For each time point starting from the `p`-th time point
#'   to `time + burn_in - 1`:
#'   * Generate a vector of random noise
#'     from a multivariate normal distribution
#'     with mean 0 and covariance matrix `chol_cov`.
#'   * Generate the VAR time series values for each variable `j` at time `t`
#'     using the formula:
#'     \deqn{Y_{tj} = constant_j +
#'     \sum_{l = 1}^{p} \sum_{m = 1}^{k} (coef_{jm} * Y_{im}) +
#'     \text{noise}_{j}}
#'     where \eqn{Y_{tj}} is the value of variable `j` at time `t`,
#'     \eqn{constant_j} is the constant term for variable `j`,
#'     \eqn{coef_{jm}} are the coefficients for variable `j`
#'     from lagged variables up to order `p`,
#'     \eqn{Y_{tm}} are the lagged values of variable `m`
#'     up to order `p` at time `t`,
#'     and \eqn{noise_{j}} is the element `j`
#'     from the generated vector of random process noise.
#' - Transpose the matrix `data` and return only
#'   the required time period after the burn-in period,
#'   which is from column `burn_in` to column `time + burn_in - 1`.
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg sim
#' @export
SimVAR <- function(time, burn_in, constant, coef, chol_cov) {
    .Call(`_simAutoReg_SimVAR`, time, burn_in, constant, coef, chol_cov)
}

#' Generate Random Data for the Variance Vector
#'
#' This function generates random data for the variance vector given by
#' \deqn{
#'   \boldsymbol{\sigma^{2}} =
#'   \exp \left( \boldsymbol{\mu} + \boldsymbol{\varepsilon} \right)
#'   \quad
#'   \text{with}
#'   \quad
#'   \boldsymbol{\varepsilon} \sim
#'   \mathcal{N} \left( \boldsymbol{0}, \boldsymbol{\Sigma} \right)
#' }.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param n Integer.
#'   Number of samples to generate.
#' @param location Numeric vector.
#'   The constant term \eqn{\boldsymbol{\mu}}.
#' @param chol_scale Numeric matrix.
#'   Cholesky decomposition of the covariance matrix \eqn{\boldsymbol{\Sigma}}
#'   for the multivariate normal random error \eqn{\boldsymbol{\varepsilon}}.
#'
#' @return Matrix with each row containing the simulated variance vector
#'   for each sample.
#'
#' @details
#' The [SimVariance()] function generates random data
#' for the variance vector
#' based on the exponential of a multivariate normal distribution.
#' Given the number of samples `n`,
#' the constant term \eqn{\boldsymbol{\mu}} represented
#' by the `location` vector,
#' and the Cholesky decomposition matrix \eqn{\boldsymbol{\Sigma}}
#' for the multivariate normal random error \eqn{\boldsymbol{\varepsilon}},
#' the function simulates \eqn{n} independent samples
#' of the variance vector \eqn{\boldsymbol{\sigma^{2}}}.
#' Each sample of the variance vector \eqn{\boldsymbol{\sigma^{2}}}
#' is obtained by
#' calculating the exponential of random variations
#' to the mean vector \eqn{\boldsymbol{\mu}}.
#' The random variations are generated using the Cholesky decomposition
#' of the covariance matrix \eqn{\boldsymbol{\Sigma}}.
#' Finally, the function returns a matrix with each column
#' containing the simulated
#' variance vector for each sample.
#'
#' @examples
#' set.seed(42)
#' n <- 100
#' location <- c(0.5, -0.2, 0.1)
#' chol_scale <- chol(
#'   matrix(
#'     data = c(1.0, 0.3, 0.3, 0.3, 1.0, 0.2, 0.3, 0.2, 1.0),
#'     nrow = 3,
#'     byrow = TRUE
#'   )
#' )
#' SimVariance(n = n, location = location, chol_scale = chol_scale)
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg sim
#' @export
SimVariance <- function(n, location, chol_scale) {
    .Call(`_simAutoReg_SimVariance`, n, location, chol_scale)
}

#' Create Y and X Matrices with Exogenous Variables
#'
#' This function creates the dependent variable (Y)
#' and predictor variable (X) matrices.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param data Numeric matrix.
#'   The time series data with dimensions `t` by `k`,
#'   where `t` is the number of observations
#'   and `k` is the number of variables.
#' @param p Integer.
#'   The order of the VAR model (number of lags).
#' @param exo_mat Numeric matrix.
#'   Matrix of exogenous variables with dimensions `t` by `m`.
#'
#' @return List containing the dependent variable (Y)
#' and predictor variable (X) matrices.
#' Note that the resulting matrices will have `t - p` rows.
#'
#' @details
#' The [YX()] function creates the `Y` and `X` matrices
#' required for fitting a Vector Autoregressive (VAR) model.
#' Given the input `data` matrix with dimensions `t` by `k`,
#' where `t` is the number of observations and `k` is the number of variables,
#' and the order of the VAR model `p` (number of lags),
#' the function constructs lagged predictor matrix `X`
#' and the dependent variable matrix `Y`.
#'
#' The steps involved in creating the `Y` and `X` matrices are as follows:
#'
#' - Determine the number of observations `t` and the number of variables `k`
#'   from the input data matrix.
#' - Create matrices `X` and `Y` to store lagged variables
#'   and the dependent variable, respectively.
#' - Populate the matrices `X` and `Y` with the appropriate lagged data.
#'   The predictors matrix `X` contains a column of ones
#'   and the lagged values of the dependent variables,
#'   while the dependent variable matrix `Y` contains the original values
#'   of the dependent variables.
#' - The function returns a list containing the `Y` and `X` matrices,
#'   which can be used for further analysis and estimation
#'   of the VAR model parameters.
#'
#' @seealso
#' The [SimVAR()] function for simulating time series data
#' from a VAR model.
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg utils
#' @export
YXExo <- function(data, p, exo_mat) {
    .Call(`_simAutoReg_YXExo`, data, p, exo_mat)
}

#' Create Y and X Matrices
#'
#' This function creates the dependent variable (Y)
#' and predictor variable (X) matrices.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param data Numeric matrix.
#'   The time series data with dimensions `t` by `k`,
#'   where `t` is the number of observations
#'   and `k` is the number of variables.
#' @param p Integer.
#'   The order of the VAR model (number of lags).
#'
#' @return List containing the dependent variable (Y)
#' and predictor variable (X) matrices.
#' Note that the resulting matrices will have `t - p` rows.
#'
#' @examples
#' set.seed(42)
#' time <- 50L
#' burn_in <- 10L
#' k <- 3
#' p <- 2
#' constant <- c(1, 1, 1)
#' coef <- matrix(
#'   data = c(
#'     0.4, 0.0, 0.0, 0.1, 0.0, 0.0,
#'     0.0, 0.5, 0.0, 0.0, 0.2, 0.0,
#'     0.0, 0.0, 0.6, 0.0, 0.0, 0.3
#'   ),
#'   nrow = k,
#'   byrow = TRUE
#' )
#' chol_cov <- chol(diag(3))
#' y <- SimVAR(
#'   time = time,
#'   burn_in = burn_in,
#'   constant = constant,
#'   coef = coef,
#'   chol_cov = chol_cov
#' )
#' yx <- YX(data = y, p = 2)
#' str(yx)
#'
#' @details
#' The [YX()] function creates the `Y` and `X` matrices
#' required for fitting a Vector Autoregressive (VAR) model.
#' Given the input `data` matrix with dimensions `t` by `k`,
#' where `t` is the number of observations and `k` is the number of variables,
#' and the order of the VAR model `p` (number of lags),
#' the function constructs lagged predictor matrix `X`
#' and the dependent variable matrix `Y`.
#'
#' The steps involved in creating the `Y` and `X` matrices are as follows:
#'
#' - Determine the number of observations `t` and the number of variables `k`
#'   from the input data matrix.
#' - Create matrices `X` and `Y` to store lagged variables
#'   and the dependent variable, respectively.
#' - Populate the matrices `X` and `Y` with the appropriate lagged data.
#'   The predictors matrix `X` contains a column of ones
#'   and the lagged values of the dependent variables,
#'   while the dependent variable matrix `Y` contains the original values
#'   of the dependent variables.
#' - The function returns a list containing the `Y` and `X` matrices,
#'   which can be used for further analysis and estimation
#'   of the VAR model parameters.
#'
#' @seealso
#' The [SimVAR()] function for simulating time series data
#' from a VAR model.
#'
#' @family Simulation of Autoregressive Data Functions
#' @keywords simAutoReg utils
#' @export
YX <- function(data, p) {
    .Call(`_simAutoReg_YX`, data, p)
}


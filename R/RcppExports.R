# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Fit Vector Autoregressive (VAR) Model Parameters using OLS
#'
#' This function estimates the parameters of a VAR model
#' using the Ordinary Least Squares (OLS) method.
#' The OLS method is used to estimate the autoregressive
#' and cross-regression coefficients.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param Y Numeric matrix.
#'   Matrix of dependent variables (Y).
#' @param X Numeric matrix.
#'   Matrix of lagged predictors (X).
#'
#' @return Matrix of estimated autoregressive and cross-regression coefficients.
#'
#' @examples
#' set.seed(42)
#' time <- 100000L
#' burn_in <- 200
#' k <- 3
#' p <- 2
#' constant <- c(1, 1, 1)
#' coef <- matrix(
#'   data = c(
#'     0.4, 0.0, 0.0, 0.1, 0.0, 0.0,
#'     0.0, 0.5, 0.0, 0.0, 0.2, 0.0,
#'     0.0, 0.0, 0.6, 0.0, 0.0, 0.3
#'   ),
#'   nrow = k,
#'   byrow = TRUE
#' )
#' chol_cov <- chol(
#'   matrix(
#'     data = c(
#'       0.1, 0.0, 0.0,
#'       0.0, 0.1, 0.0,
#'       0.0, 0.0, 0.1
#'     ),
#'     nrow = k,
#'     byrow = TRUE
#'   )
#' )
#' y <- SimVAR(
#'   time = time,
#'   burn_in = burn_in,
#'   constant = constant,
#'   coef = coef,
#'   chol_cov = chol_cov
#' )
#' yx <- YX(y, p)
#' FitVAROLS(Y = yx$Y, X = yx$X)
#'
#' @details
#' The \code{FitVAROLS} function estimates the parameters of a Vector Autoregressive (VAR) model using the Ordinary Least Squares (OLS) method.
#' Given the input matrices \code{Y} and \code{X}, where \code{Y} is the matrix of dependent variables, and \code{X} is the matrix of lagged predictors,
#' the function computes the autoregressive and cross-regression coefficients of the VAR model.
#'
#' The steps involved in estimating the VAR model parameters using OLS are as follows:
#'
#' \itemize{
#'   \item Compute the QR decomposition of the lagged predictor matrix \code{X} using the \code{qr_econ} function from the Armadillo library.
#'   \item Extract the \code{Q} and \code{R} matrices from the QR decomposition.
#'   \item Solve the linear system \code{R * coef = Q.t() * Y} to estimate the VAR model coefficients \code{coef}.
#' }
#'
#' The function returns a matrix containing the estimated autoregressive and cross-regression coefficients of the VAR model.
#'
#' @seealso
#' The \code{qr_econ} function from the Armadillo library for QR decomposition.
#'
#' @importFrom Rcpp sourceCpp
#'
#' @export
FitVAROLS <- function(Y, X) {
    .Call(`_simAutoReg_FitVAROLS`, Y, X)
}

#' Simulate Data from an Autoregressive Model with Constant Term
#'
#' This function generates synthetic time series data
#' from an autoregressive (AR) model.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param time Integer.
#'   Number of time points to simulate.
#' @param burn_in Integer.
#'   Number of burn-in periods before recording data.
#' @param constant Numeric.
#'   The constant term of the AR model.
#' @param coef Numeric vector.
#'   Autoregressive coefficients.
#' @param sd Numeric.
#'   The standard deviation of the random noise.
#'
#' @return Numeric vector containing the simulated time series data.
#'
#' @examples
#' set.seed(42)
#' SimAR(time = 10, burn_in = 5, constant = 2, coef = c(0.5, -0.3), sd = 0.1)
#'
#' @details
#' The \code{SimAR} function generates synthetic time series data from an autoregressive (AR) model.
#' The generated data follows the AR(p) model, where \code{p} is the number of coefficients specified in \code{coef}.
#' The generated time series data includes a constant term and autoregressive terms based on the provided coefficients.
#' Random noise, sampled from a normal distribution with mean 0 and standard deviation \code{sd}, is added to the time series.
#' Additionally, a burn-in period can be specified to exclude initial data points from the output. 
#'
#' The steps in generating the autoregressive time series with burn-in are as follows:
#'
#' \itemize{
#'   \item Set the order of the AR model to \code{p}.
#'   \item Generate random noise from a normal distribution with mean 0 and standard deviation \code{sd}.
#'   \item Generate the autoregressive time series with burn-in using the formula:
#'   \deqn{Y_t = constant + \sum_{i=1}^{p} (coef[i] * Y_{t-i}) + noise_t}
#'   where \eqn{Y_t} is the time series data at time \eqn{t}, \eqn{constant} is the constant term, 
#'   \eqn{coef[i]} are the autoregressive coefficients, \eqn{Y_{t-i}} are the lagged data points up to order \code{p},
#'   and \eqn{noise_t} is the random noise at time \eqn{t}.
#'   \item Optionally, remove the burn-in period from the generated time series data.
#' }
#'
#' @export
SimAR <- function(time, burn_in, constant, coef, sd) {
    .Call(`_simAutoReg_SimAR`, time, burn_in, constant, coef, sd)
}

#' Simulate Multivariate Normal Random Numbers
#'
#' This function generates multivariate normal random numbers.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param n Integer.
#'   Number of samples to generate.
#' @param location Numeric vector.
#'   Mean vector of length k, where k is the number of variables.
#' @param chol_scale Numeric matrix.
#'   Cholesky decomposition of the covariance matrix of dimensions k x k.
#'
#' @return Matrix containing the simulated multivariate normal random numbers,
#'   with dimensions n x k, where n is the number of samples
#'   and k is the number of variables.
#'
#' @examples
#' set.seed(42)
#' n <- 100000L
#' location <- c(0.5, -0.2, 0.1)
#' scale <- matrix(
#'   data = c(1.0, 0.3, 0.3, 0.3, 1.0, 0.2, 0.3, 0.2, 1.0),
#'   nrow = 3,
#'   byrow = TRUE
#' )
#' chol_scale <- chol(scale)
#' y <- SimMVN(n = n, location = location, chol_scale = chol_scale)
#' colMeans(y)
#' var(y)
#'
#' @details
#' The \code{SimMVN} function generates multivariate normal random numbers using the Cholesky decomposition method.
#' Given the number of samples \code{n}, the mean vector \code{location} of length k (where k is the number of variables),
#' and the Cholesky decomposition \code{chol_scale} of the covariance matrix of dimensions k x k,
#' the function produces a matrix of multivariate normal random numbers.
#'
#' The steps involved in generating multivariate normal random numbers are as follows:
#'
#' \itemize{
#'   \item Determine the number of variables \code{k} from the length of the mean vector.
#'   \item Generate random data from a standard multivariate normal distribution, resulting in an n x k matrix of random numbers.
#'   \item Transform the standard normal random data into multivariate normal random data using the Cholesky decomposition \code{chol_scale}.
#'   \item Add the mean vector \code{location} to the transformed data to obtain the final simulated multivariate normal random numbers.
#' }
#'
#' The function returns a matrix of simulated multivariate normal random numbers with dimensions n x k,
#' where n is the number of samples and k is the number of variables. This matrix can be used for various statistical analyses and simulations.
#'
#' @seealso
#' The \code{chol} function in R to obtain the Cholesky decomposition of a covariance matrix.
#'
#' @importFrom Rcpp sourceCpp
#'
#' @export
SimMVN <- function(n, location, chol_scale) {
    .Call(`_simAutoReg_SimMVN`, n, location, chol_scale)
}

#' Simulate Data from a Vector Autoregressive Zero-Inflated Poisson (VARZIP) Model
#'
#' This function generates synthetic time series data
#' from a Vector Autoregressive Zero-Inflated Poisson (VARZIP) model.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param time Integer.
#'   Number of time points to simulate.
#' @param burn_in Integer.
#'   Number of burn-in observations to exclude before returning the results.
#' @param constant Numeric vector.
#'   The constant term vector of length k, where k is the number of variables.
#' @param coef Numeric matrix.
#'   Coefficient matrix with dimensions k x (k * p).
#'   Each k x k block corresponds to the coefficient matrix
#'   for a particular lag.
#' @param chol_cov Numeric matrix.
#'   The Cholesky decomposition of the covariance matrix
#'   of the multivariate normal noise.
#'   It should have dimensions k x k.
#'
#' @return Numeric matrix containing the simulated time series data
#'   with dimensions k x (time - burn_in),
#'   where k is the number of variables and time is the number of observations.
#'
#' @examples
#' set.seed(42)
#' time <- 100000L
#' burn_in <- 200
#' k <- 3
#' p <- 2
#' constant <- c(1, 1, 1)
#' coef <- matrix(
#'   data = c(
#'     0.4, 0.0, 0.0, 0.1, 0.0, 0.0,
#'     0.0, 0.5, 0.0, 0.0, 0.2, 0.0,
#'     0.0, 0.0, 0.6, 0.0, 0.0, 0.3
#'   ),
#'   nrow = k,
#'   byrow = TRUE
#' )
#' chol_cov <- chol(
#'   matrix(
#'     data = c(
#'       0.1, 0.0, 0.0,
#'       0.0, 0.1, 0.0,
#'       0.0, 0.0, 0.1
#'     ),
#'     nrow = k,
#'     byrow = TRUE
#'   )
#' )
#' y <- SimVARZIP(
#'   time = time,
#'   burn_in = burn_in,
#'   constant = constant,
#'   coef = coef,
#'   chol_cov = chol_cov
#' )
#' head(y)
#'
#' @details
#' The \code{SimVARZIP} function generates synthetic time series data from a Vector Autoregressive Zero-Inflated Poisson (VARZIP) model.
#' The VARZIP model is an extension of the Vector Autoregressive (VAR) model with zero-inflated Poisson (ZIP) count process.
#' The VARZIP model is defined by the constant term \code{constant}, the coefficient matrix \code{coef},
#' and the Cholesky decomposition of the covariance matrix of the multivariate normal noise \code{chol_cov}.
#' The generated time series data follows a VAR(p) process, where \code{p} is the number of lags specified by the size of \code{coef}.
#' The first variable in the VARZIP model follows a ZIP process, where it can be either zero-inflated or generated from a Poisson distribution.
#' The generated data includes a burn-in period, which is excluded before returning the results.
#'
#' The steps involved in generating the VARZIP time series data are as follows:
#'
#' \itemize{
#'   \item Extract the number of variables \code{k} and the number of lags \code{p} from the input.
#'   \item Create a matrix \code{data} of size \code{k} x (\code{time + burn_in}) to store the generated VARZIP time series data.
#'   \item Set the initial values of the matrix \code{data} using the constant term \code{constant}.
#'   \item For each time point starting from the \code{p}-th time point to \code{time + burn_in - 1}:
#'   \item Generate a vector of random noise from a multivariate normal distribution with mean 0 and covariance matrix \code{chol_cov}.
#'   \item Generate the VAR time series values for each variable \code{j} at time \code{i} by applying the autoregressive terms for each lag \code{lag} and each variable \code{l}.
#'   \item Add the generated noise to the VAR time series values.
#'   \item For the first variable, apply the Zero-Inflated Poisson (ZIP) model:
#'   \item Compute the intensity \code{intensity} as the exponential of the first variable's value at time \code{i}.
#'   \item Sample a random value \code{u} from a uniform distribution on [0, 1].
#'   \item If \code{u} is less than \code{intensity / (1 + intensity)}, set the first variable's value to zero (inflation).
#'   \item Otherwise, sample the first variable's value from a Poisson distribution with mean \code{intensity} (count process).
#'   \item Transpose the data matrix \code{data} and return only the required time period after burn-in as a numeric matrix.
#'}
#'
#' @export
NULL

#' Simulate Data from a Vector Autoregressive (VAR) Model
#'
#' This function generates synthetic time series data
#' from a Vector Autoregressive (VAR) model.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param time Integer.
#'   Number of time points to simulate.
#' @param burn_in Integer.
#'   Number of burn-in observations to exclude before returning the results.
#' @param constant Numeric vector.
#'   The constant term vector of length k, where k is the number of variables.
#' @param coef Numeric matrix.
#'   Coefficient matrix with dimensions k x (k * p).
#'   Each k x k block corresponds to the coefficient matrix
#'   for a particular lag.
#' @param chol_cov Numeric matrix.
#'   The Cholesky decomposition of the covariance matrix
#'   of the multivariate normal noise.
#'   It should have dimensions k x k.
#'
#' @return Numeric matrix containing the simulated time series data
#'   with dimensions k x (time - burn_in),
#'   where k is the number of variables and time is the number of observations.
#'
#' @examples
#' set.seed(42)
#' time <- 100000L
#' burn_in <- 200
#' k <- 3
#' p <- 2
#' constant <- c(1, 1, 1)
#' coef <- matrix(
#'   data = c(
#'     0.4, 0.0, 0.0, 0.1, 0.0, 0.0,
#'     0.0, 0.5, 0.0, 0.0, 0.2, 0.0,
#'     0.0, 0.0, 0.6, 0.0, 0.0, 0.3
#'   ),
#'   nrow = k,
#'   byrow = TRUE
#' )
#' chol_cov <- chol(
#'   matrix(
#'     data = c(
#'       0.1, 0.0, 0.0,
#'       0.0, 0.1, 0.0,
#'       0.0, 0.0, 0.1
#'     ),
#'     nrow = k,
#'     byrow = TRUE
#'   )
#' )
#' y <- SimVAR(
#'   time = time,
#'   burn_in = burn_in,
#'   constant = constant,
#'   coef = coef,
#'   chol_cov = chol_cov
#' )
#' head(y)
#'
#' @details
#' The \code{SimVAR} function generates synthetic time series data from a Vector Autoregressive (VAR) model.
#' The VAR model is defined by the constant term \code{constant}, the coefficient matrix \code{coef},
#' and the Cholesky decomposition of the covariance matrix of the multivariate normal noise \code{chol_cov}.
#' The generated time series data follows a VAR(p) process, where \code{p} is the number of lags specified by the size of \code{coef}.
#' The generated data includes a burn-in period, which is excluded before returning the results.
#'
#' The steps involved in generating the VAR time series data are as follows:
#'
#' \itemize{
#'   \item Extract the number of variables \code{k} and the number of lags \code{p} from the input.
#'   \item Create a matrix \code{data} of size \code{k} x (\code{time + burn_in}) to store the generated VAR time series data.
#'   \item Set the initial values of the matrix \code{data} using the constant term \code{constant}.
#'   \item For each time point starting from the \code{p}-th time point to \code{time + burn_in - 1}:
#'   \item Generate a vector of random noise from a multivariate normal distribution with mean 0 and covariance matrix \code{chol_cov}.
#'   \item Generate the VAR time series values for each variable \code{j} at time \code{i} using the formula:
#'   \deqn{Y_{ij} = constant_j + \sum_{l=1}^{p} \sum_{m=1}^{k} (coef_{jm} * Y_{im}) + \text{noise}_{j}}
#'   where \eqn{Y_{ij}} is the value of variable \code{j} at time \code{i},
#'   \code{constant_j} is the constant term for variable \code{j},
#'   \code{coef_{jm}} are the coefficients for variable \code{j} from lagged variables up to order \code{p},
#'   \eqn{Y_{im}} are the lagged values of variable \code{m} up to order \code{p} at time \code{i},
#'   and \code{noise_{j}} is the element \code{j} from the generated vector of random noise.
#'   \item Transpose the matrix \code{data} and return only the required time period after the burn-in period, which is from column \code{burn_in} to column \code{time + burn_in - 1}.
#' }
#'
#' @export
SimVAR <- function(time, burn_in, constant, coef, chol_cov) {
    .Call(`_simAutoReg_SimVAR`, time, burn_in, constant, coef, chol_cov)
}

#' Generate Random Data for the Variance Vector
#'
#' This function generates random data for the variance vector given by
#' \deqn{
#'   \boldsymbol{\sigma^{2}} =
#'   \exp \left( \boldsymbol{\mu} + \boldsymbol{\varepsilon} \right)
#'   \quad
#'   \text{with}
#'   \boldsymbol{\varepsilon} \sim
#'   \mathcal{N} \left( \boldsymbol{0}, \boldsymbol{\Sigma} \right)
#' }.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param n Integer.
#'   Number of samples to generate.
#' @param location Numeric vector.
#'   The constant term \eqn{\boldsymbol{\mu}}.
#' @param chol_scale Numeric matrix.
#'   Cholesky decomposition of the covariance matrix \eqn{\boldsymbol{\Sigma}}
#'   for the multivariate normal random error \eqn{\boldsymbol{\varepsilon}}.
#'
#' @return Matrix with each row containing the simulated variance vector
#'   for each sample.
#'
#' @examples
#' set.seed(42)
#' n <- 100
#' location <- c(0.5, -0.2, 0.1)
#' chol_scale <- chol(
#'   matrix(
#'     data = c(1.0, 0.3, 0.3, 0.3, 1.0, 0.2, 0.3, 0.2, 1.0),
#'     nrow = 3,
#'     byrow = TRUE
#'   )
#' )
#' SimVariance(n = n, location = location, chol_scale = chol_scale)
#'
#' @export
SimVariance <- function(n, location, chol_scale) {
    .Call(`_simAutoReg_SimVariance`, n, location, chol_scale)
}

#' Create Y and X Matrices
#'
#' This function creates the Y and X matrices.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @param data Numeric matrix.
#'   The time series data with dimensions n x k,
#'   where n is the number of observations and k is the number of variables.
#' @param p Integer.
#'   The order of the VAR model (number of lags).
#'
#' @return List containing the Y and X matrices.
#'
#' @examples
#' set.seed(42)
#' time <- 100000L
#' burn_in <- 200
#' k <- 3
#' p <- 2
#' constant <- c(1, 1, 1)
#' coef <- matrix(
#'   data = c(
#'     0.4, 0.0, 0.0, 0.1, 0.0, 0.0,
#'     0.0, 0.5, 0.0, 0.0, 0.2, 0.0,
#'     0.0, 0.0, 0.6, 0.0, 0.0, 0.3
#'   ),
#'   nrow = k,
#'   byrow = TRUE
#' )
#' chol_cov <- chol(
#'   matrix(
#'     data = c(
#'       0.1, 0.0, 0.0,
#'       0.0, 0.1, 0.0,
#'       0.0, 0.0, 0.1
#'     ),
#'     nrow = k,
#'     byrow = TRUE
#'   )
#' )
#' y <- SimVAR(
#'   time = time,
#'   burn_in = burn_in,
#'   constant = constant,
#'   coef = coef,
#'   chol_cov = chol_cov
#' )
#' yx <- YX(data = y, p = p)
#' str(yx)
#'
#' @details
#' The \code{YX} function creates the Y and X matrices required for fitting a Vector Autoregressive (VAR) model.
#' Given the input \code{data} matrix with dimensions n x k, where n is the number of observations and k is the number of variables,
#' and the order of the VAR model \code{p} (number of lags), the function constructs lagged predictor matrix X and the dependent variable matrix Y.
#' The matrices X and Y are used as inputs for estimating the VAR model parameters.
#'
#' The steps involved in creating the Y and X matrices are as follows:
#'
#' \itemize{
#'   \item Determine the number of observations \code{n} and the number of variables \code{k} from the input data matrix.
#'   \item Create matrices X and Y to store lagged variables and the dependent variable, respectively.
#'   \item Populate the matrices X and Y with the appropriate lagged data. The predictors matrix X contains the lagged values of the dependent variables,
#'     while the dependent variable matrix Y contains the original values of the dependent variables.
#' }
#'
#' The function returns a list containing the Y and X matrices, which can be used for further analysis and estimation of the VAR model parameters.
#'
#' @seealso
#' The \code{SimVAR} function for simulating time series data from a VAR model.
#'
#' @importFrom Rcpp sourceCpp
#'
#' @export
YX <- function(data, p) {
    .Call(`_simAutoReg_YX`, data, p)
}

